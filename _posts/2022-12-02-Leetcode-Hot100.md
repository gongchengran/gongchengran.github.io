### Date：12.1

#### 121.买卖股票的最佳时期

Ori: 暴力法会超时

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int pro = 0;
        int n = prices.size();
        for(int i = 0; i < n; i++)
        {
            for(int j = i+1; j < n; j++)
            {
                    pro = max(pro, prices[j]-prices[i]);
            }
        }
        return pro;
    }
};
```

动态规划：遍历一遍即可

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int maxpro = 0;
        int minpri = int(1e9);
        for(auto price:prices)
        {
            maxpro = max(maxpro,price-minpri);
            minpri = min(minpri, price);
        }
        return maxpro;
    }
};
```



#### 169.多数元素

方法1：Hashtable

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size()/2;
        int res = 0;
        unordered_map<int,int> hash;
        for(auto num:nums)
        {
            ++hash[num];
            if(hash[num]>n)
            {
                res = num;
            }
        }
        return res;
    }
};
```

方法2：排序

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums[nums.size()/2];
    }
};
```



#### 283.移动零

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
		for(int i=0,j=0;i!=nums.size();++i) 
		if(nums[i]) swap(nums[i],nums[j++]);
    }
};
```

### Date: 12.5
#### 283.移动零
#### Tips: 使用双指针，将非零元素移动至数组前方，后面缺的补零即可
```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int k = 0;
        for(int x : nums)
        {
            if(x != 0)
            {
                nums[k] = x;
                k++;
            }
        }
        while(k < nums.size()) nums[k++] = 0;
    }
};
```

#### 448.找到所有数组中消失的数字
##### Tips：注意使用set关联式容器，可以使用find进行搜索，而动态数组vector不可以使用！！！
```
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        set<int> s;
        vector<int> res;
        for(int i = 0; i < n; i++)
        {
            s.insert(nums[i]);
        }
        for(int i = 1; i <= n; i++)
        {
            if(s.find(i) == s.end())
            {
                res.push_back(i);
            }
        }
        return res;
    }
};
```

#### 11.盛最多水的容器

##### 法1（双循环更新最大值）

**Tips：在Leetcode上运行超时，但在VS上顺利运行并编译通过**

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0;
        int n = height.size();
        for(int i = 0; i < n; i++)
        {
            for(int j = n-1; j > i; j--)
            {
                int temp = min(height[i],height[j])*(j-i);
                res = max(res, temp);
            }
        }
        return res;
    }
};
```



##### 法2（双指针）

**Tips：无论短板长板向内收缩时横轴都会少1，短板向内缩短时短板可能变长，结果可能变大；而长板收缩时结果一定会变小，因此解题步骤为：**

**1 短板收缩，更新结果  **

**2 更新短板**

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() - 1, res = 0;
        while(i < j)
        {
            res = max(res, min(height[i],height[j])*(j-i));
            height[i]<height[j]?i++:j--;
        }
        return res;
    }
};
```

##### 22 括号生成

Tips：深度优先遍历 

思想：递归

条件1：左右括号数量相同

条件2：任意前缀中左括号数目 大于等于 右括号数目

搜索过程：

1、初始时定义序列的左括号数量lc 和右括号数量rc都为0。
2、如果 lc < n，左括号的个数小于n，则在当前序列str后拼接左括号。
3、如果 rc < n && lc > rc , 右括号的个数小于左括号的个数，则在当前序列str后拼接右括号。
4、当lc == n && rc == n 时，将当前合法序列str加入答案数组res中。

```
class Solution {
public:
    vector<string> res;
    string s;
    void dfs(int n, int l, int r)
    {
        if(l == n && r == n) res.push_back(s);
        if(l < n)
        {
            s += '(';
            dfs(n,l+1,r);
            s.pop_back();
        } 
        if(r < n && l > r)
        {
            s += ')';
            dfs(n,l,r+1);
            s.pop_back();
        }
    }

    vector<string> generateParenthesis(int n) {
        dfs(n,0,0);
        return res;
    }
};
```


